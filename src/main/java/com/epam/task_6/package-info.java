/**
 * Модель "справочник музыкального магазина"
 * ...
 * Исполнитель: <имя исполнителя>
 *     Альбом: <название>, <жанр>
 *         Композиция: <название>, <длительность>
 *         ...
 *     Альбом: ...
 * ...
 *
 *
 * 1. Создаём джавовую модель
 * 2. Создаём интерфейс сериализатора / десериализатора. Он будет сохранять данные в указанный текстовый формат.
 * 3. Создаём entity класс, имплементирующий Serializable
 * 4. Создаём ещё одну имплементацию сериализатора, в этот раз чтобы она сериализовала entity классы.
 * 5. При загрузках данные должны валидироваться: альбом без композиций - отмывание денег, а не музыка; исполнитель без альбомов - тоже странный (инди отбрасываются как погрешность)
 *
 * Дополнительное необязательное задание (может помочь понять смысл разделения модели и entity класса)
 * *. Декомпозируем сохраняемый результат так, чтобы одна и та же композиция встречалась в выходном файле лишь один раз, даже если она относится к двум исполнителям.
 * Текстовый формат вывода придумайте сами. Единственное условие: он должен быть полностью понятен человеку (то есть никакого перечисления непонятных полей без имён через запятую)
 *
 * Уточнение по домашней работе с сериализацией: мы формально делим приложение на 2 слоя - калькуляционный и слой хранения.
 * Весь калькуляционный слой работает с вашей джавовой моделью музыкантов, но как только мы хотим всё это сохранить,
 * то работа уходит на слой хранения, тот должен преобразовать вашу модель в entity модель и сохранять уже её.
 * С сохранением в текстовый формат своя отдельная entity модель не требуется, если что.
 **/
package com.epam.task_6;